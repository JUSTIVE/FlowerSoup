# Functional Programming

1장에서 보았듯 순수 함수형 프로그래밍은 함수를 포함한 모든 것들을 값으로 봅니다.\
비록 F#은 순수 함수형 프로그래밍 언어는 아니지만 부작용을 지니는 선언 대신 값을 반환하는 표현이나 계산들을 반환하는 것처럼 함수형 스타일로 작성할 수 있게 합니다.\
이 장에서는 F#에서 함수형 프로그래밍을 지원하게 하는 대부분의 구성요소들을 만나고 그것들이 함수형 프로그래밍을 쉽게 하는 것을 배울 것입니다.

## 리터럴

리터럴은 상수 값을 의미하며, 계산에 유용한 블록들입니다. F#은 다양한 리터럴을 지원합니다.

|예시|F#타입|.Net 타입|설명|
|---|---|---|---|
|"Hello\t","World\n"|string|System.String|이스케이프 문자(\)를 포함한 문자열입니다|
|@"c:\dir\fs",@""""|string|System.String|축자(verbatim) 문자열입니다. (\)는 일반 문자로 취급됩니다|
|"bytesbytesbytes"B|byte array|System.Byte|바이트 배열로 저장될 문자열입니다|
|'c'|char|System.Char|문자입니다|
|true,false|bool|System.Boolean|불리언 값입니다|
|0x22|int/int32|System.Int32|16진수 정수입니다|
|0o42|int/int32|System.Int32|8진수 정수입니다|
|0b10010|int/int32|System.Int32|2진수 정수입니다|
|34y|sbyte|System.SByte|부호를 가진 바이트입니다|
|34uy|byte|System.Byte|부호를 가지지 않는 바이트입니다|
|34s|int16|System.Int16|16비트 정수입니다|
|34us|uint16|System.UInt16|부호를 가지지 않는 16비트 정수입니다|
|34l|int/int32|System.Int32|32비트 정수입니다|
|34ul|uint32|System.UInt32|부호를 가지지 않는 32비트 정수입니다|
|34n|nativeint|System.IntPtr|네이티브 크기를 가지는 정수입니다|
|34un|unativeint|System.UIntPtr|네이티브 크기를 가지는 정수입니다|
|34L|int64|System.Int64|32비트 정수입니다|
|34UL|int64|System.Int64|부호를 가지지 않는 32비트 정수입니다|
|3.0F,3.0f|float32|System.Single|IEEE 32비트 부동소수점 실수입니다|
|3.0|float|System.Double|IEEE 64비트 부동소수점 실수입니다|
|3473262622571I|bigint|Microsoft.FSharp.Math.BigInt|임의의 큰 정수입니다|
|47426261253617N|bignum|Microsoft.FSharp.Math.BigNum|임의의 큰 수입니다|

F# 에서는 문자열 리터럴이 뉴라인 문자를 포함할 수 있고, 정규 문자열은 일반 이스케이프 코드를 포함할 수 있습니다.\
Verbatim 문자열은 `\`를 일반 문자로 사용하고, `""`는 구의 이스케이프 문자로 사용합니다.\
적절한 접두사와 접두 지시어를 이용하면 모든 정수를 8진법 혹은 16진법으로 표현할 수 있습니다.\
\
다음의 예제는 실제 리터럴이 F#의 printf 함수의 %A 패턴을 이용하여 값을 화면에 출력하는 것입니다.\
Printf 함수는 `%A`패턴을 F#의 리플렉션과 .Net ToString 메소드를 조합하여 사용하고, 이를 통해 사람이 읽을 수 있는 방법으로 값을 출력합니다.

```Fsharp
//some strings
let message = "Hello
World\r\n\t!"
let dir = @"c:\projects"
//a byte array
let bytes = "bytesbytesbytes"B
//some numeric types
let xA = 0xFFy
let xB = 0o7777un
let xC = 0b10010UL
//print the results
let main()=
    printfn "%A" message
    printfn "%A" dir
    printfn "%A" bytes
    printfn "%A" xA
    printfn "%A" xB
    printfn "%A" xC
//call the main function
main()
```

## 함수
F#에서의 함수는 `fun` 키워드로 정의합니다.\
함수의 인자는 스페이스로 구분되고, 함수의 몸과 인자는 오른쪽 ASCII 화살표`->`로 구분됩니다.\
\
다음은 두 값을 받고 더하는 함수의 예제입니다.

```fsharp
fun x y -> x + y
```

함수의 이름이 없는 것에 주목하세요. 이것은 함수 리터럴같은 종류입니다.\
이런 방법으로 정의된 함수는 `익명 함수`, `람다 함수` 혹은 `람다` 라고 불립니다.\
함수가 이름을 가지지 않는다는 발상이 조금 이상하게 보일 수 있습니다.\
그러나 함수가 다른 함수의 인자로 넘어가야한다면 이름이 필요없을 수도 있습니다.\
특히 그 함수가 너무 간단한 내용이라면요.\
만약 함수에 이름을 주고 싶다면, 식별자에 바인드할 수 있습니다. 이는 다음 장에서 다룹니다.

## 식별자와 let 바인딩
`식별자`는 F#의 값들에 이름을 주는 방식으로, 이를 통해 프로그램에서 나중에 그 값들을 참조할 수 있습니다.\
`let` 키워드 다음에 `식별자 이름 = 표현식`을 사용함으로써 식별자를 정의할 수 있습니다.\
표현식은 값을 반환할 계산식을 나타내는 아무 코드 조각을 의미합니다.\
\
다음의 표현식은 값이 식별자에 배정되는 것을 보여줍니다.

```fsharp
let x = 42
```

대부분의 명령형 프로그래밍의 배경을 가지고 있는 사람들에게, 이것은 변수 배정과 비슷하게 보일 것입니다.\
많은 공통점이 있지만, 본질적으로 다른 부분은 순수 함수형 프로그래밍에서 한번 배정된 값은 절대 변하지 않는다는 것에 있습니다.\
이는 이 책에서 `변수` 대신 `식별자`로 표현하는 이유입니다.

> 특정한 상황에서, 식별자를 재지정할 수 있습니다. 이는 식별자를 바뀌는 값으로 보이게 할 수 있지만, 약간 다릅니다. 또한, F# 에서의 명령형 프로그래밍에서는 특정한 상황에서 식별자의 값을 바꿀 수 있습니다. 이 장에서는 함수형 프로그래밍에 집중하며,식별자는 바뀌지 않는 값으로 간주합니다.

놀랍게도 F#의 함수는 실제로는 그 자체로 값이기 때문에 식별자는 값 혹은 함수를 의미할 수 있습니다.\
이는 F#에서는 사실 함수 혹은 인자 이름이라는 사실적인 개념이 없다는 것을 의미합니다; 이들은 그저 식별자입니다.\
정수 리터럴 혹은 문자열 리터럴을 식별자에 바인딩하듯이 익명 함수를 식별자에 바인딩 할 수 있습니다.

```fsharp
let myAdd = fun x y -> x + y
```

반면, 함수를 이름으로 정의하는 것은 매우 일반적이므로, F#은 이를 위한 짧은 문법을 제공합니다.\
다음과 같이 값 식별자를 정의하는 것처럼 함수를 정의하되, 함수는 let 키워드와 `=` 사이에 두개 이상의 식별자를 가질수 있습니다.

```fsharp 
let raisePowerTwo x = x ** 2.0
```

첫 식별자는 함수의 이름이고, 두 번째 식별자는 함수의 인자의 이름입니다.\
만약 함수의 이름이 있다면, 짦은 문법을 이용하여 정의하는 것을 강력히 추천합니다.

F#에서는 function이 값이고, F#의 문법은 이들을 비슷하게 다루기 때문에 *value*와 *function*을 정의하는 것은 구분할 수 없습니다.

```fsharp
let n = 10
let add a b = a + b
let result = add n 4
printfn "result = %i" result
```

