# 기본 문법들

## F# 에서의 토큰들

F# 프로그램은 다양한 토큰들을 포함하고 있다. 토큰은 키워드, 식별자, 상수, 리터럴 문자열, 심볼일 수 있다. 우리는 F# 토큰을 두 종류로 구분할 수 있다.
- 키워드
- 심볼과 연산자

### F# 키워드

다음의 표는 키워드들과 간단한 설명을 나타낸 것이다.

키워드|설명
---|---
**abstrct**|선언된 타입의 구현이 되어있지 않거나 기본 구현을 사용하거나 가상 메소드에 사용됩니다.
**and**|재귀 바인딩, 속성 정의, 제너릭 인자의 다중 제약에 사용됩니다.
**as**|현재 클래스 객체에 객체 이름을 부여할 때 사용됩니다. 또한 패턴매칭에서 전체 패턴에 이름을 부여할 때도 사용됩니다.
**assert**|디버깅 시 코드를 증명할 때 사용됩니다. 
**base**| 부모 클래스 객체의 이름처럼 사용됩니다.
**begin**|긴 문법에서 코드 블록의 시작을 나타냅니다.
**class**|긴 문법에서 클래스 정의의 시작을 나타냅니다.
**default**|추상 클래스의 구현의 시작을 나타냅니다. 가상 메소드를 만추상 클래스 선언과 가상메소드를 생성하기 위해 추상 메소드 선언과 같이 사용됩니다.
**delegate**|delegate를 선언할 때 사용됩니다.
**do**|루프 구조나 명령형 코드를 실행할 때에 사용됩니다
**done**|긴 문법에서 루프 표현의 코드 블럭의 끝을 나타냅니다
**downcast**|상속 체인에서 낮은 타입으로 변환할 때 사용됩니다.
**downto**| for 문에서 역순으로 셀 때 사용합니다.
**elif**| 조건 분기문에서 else if 의 약칭으로 사용합니다.
**else**| 조건 분기문에서 사용됩니다.
**end**| 타입 정의와 타입 확장, 멤버 정의의 끝을 의미합니다. verbose한 문법에서는 `begin`으로 시작한 코드 블럭을 닫을 때 사용합니다
**exception**| 예외 타입을 선언할 때 사용합니다.
**extern**| 다른 바이너리 혹은 어셈블리에서 정의된 프로그램 요소를 지시합니다.
**false**| boolean 리터럴로 사용됩니다.
**finally**| try 와 함께 쓰이며, 예외의 여부와 관계 없이 실행할 코드 블럭을 지정합니다.
**for**| 반복하는 구조에 사용합니다.
**fun**| 람다라 불리는 익명함수의 표현에 사용됩니다.
**function**|  `fun`약어로 주로 사용되며, match 표현에서는 하나의 인자에 대한 패턴매칭 람다 표현으로 사용됩니다.
**global**| 최상위 .NET 네임스페이스를 참조할 때 사용합니다.
**if**| 조건 분기 구조에 사용됩니다.
**in**| sequence 표현에 사용되고, verbose한 문법에서는 표현과 바인딩을 분리하기 위해 사용합니다.
**inherit**| 부모 클래스나 부모 인터페이스를 명시할 때 사용합니다.
**inline**| 호출자의 코드에 직접적으로 통합될 함수를 지시할 때 사용합니다.
**interface**| 인터페이스를 선언하고 구현할 때에 사용합니다
**internal**| 멤버가 어셈블리 내부적으로는 가시적이나 외부로는 비가시적임을 명시할 때 사용합니다.
**lazy**| 결과가 필요한 순간에 수행될 계산을 명시할 때 사용합니다.
**let**| 함수 혹은 변수에 이름을 바인딩, 연관할 때 사용합니다.
**let**! | 비동기 작업에서 비동기 계산의 결과를 바인딩 할 때 사용하거나, 다른 계산 타입의 결과를 이름에 바인딩 할 때 사용합니다.
**match**| 패턴과 값을 비교하는 분기에 사용합니다.
**member**| 객체 타이브이 메소드 혹은 속성을 선언할 때 사용합니다.
**module**| 연관된 값, 함수, 타입, 함수를 이름에 결합하여 다른 코드와 논리적으로 분리할 때 사용합니다.
**mutable**| 변할 수 있는 값인 변수를 선언할 때 사용합니다.
**namespace**| 연관된 타입과 모듈을 이름에 결합하여 다른 코드와 논리적으로 분리할 때 사용합니다.
**new**| 객체를 생성할 수 있는 생성자를 선언, 정의, 호출할 때 사용합니다. 또한, 제네릭 인자 제약에서 타입이 특정한 생성자를 반드시 가져야 함을 나타낼 때 사용하기도 합니다.
**not**| 사실, 키워드는 아니지만 조합에서의 not 구조는 제네릭 인자 제약으로 사용됩니다.
**null**| 객체의 부재를 나타냅니다. 또한 제네릭 인자 제약에 사용되기도 합니다.
**of**| 구분 유니온에서 카테고리의 값의 타입을 나타내기 위해 사용하고, 델리게이트와 예외 선언문에서 사용합니다.
**open**| 별도의 접두어 없이 네임스페이스 혹은 모듈의 콘텐츠를 사용하게 할 때 사용합니다.
**or**| 불리언 혹은 연산자로 불리언 조건과 사용됩니다. `||`에 대응됩니다. 또한 멤버 제약에도 사용됩니다.
**override**| 부모 클래스와 다르며 구현되지 않은 추상 혹은 가상 메소드에 사용됩니다.
**private**| 같은 타입 혹은 모듈안의 코드들로 멤버 접근을 제한합니다.
**public**| 타입의 바깥으로부터의 멤버 접근을 허용합니다.
**rev**| 함수가 재귀적임을 명시합니다.
**return**| 값이 계산 표현의 결과로 제공되어짐을 지시할 때 사용합니다.
**return**!| 결과가 포함된 계산 표현이 평가되었을 때 제공되어짐을 지시할 때 사용합니다.
**select**| 쿼리 표현에서 어떤 필드 혹은 컬럼이 추출되어야하는 지 명시할 때 사용합니다. 이는 문맥적인 키워드이며, 사실은 예약어가 아니고 특정한 문맥에서만 키워드로 사용됨을 의미합니다.
**static**| 타입의 인스턴스 없이 호출되어질 수 있는 메소드 혹은 속성이나 어느 타입의 모든 인스턴스에 걸쳐서 공유되는 변수 멤버에 사용합니다.
**struct**| 구조체 타입을 선언할 때 사용합니다. 제네릭 인자 제약에도 사용됩니다. 모듈 선언에서 OCaml 호환을 위해 사용됩니다.
**then**| 조건 표현에 사용됩니다. 객체 생성후의 부작용 수행에도 사용됩니다.
**to**| for 루프에서 범위를 지정할 때 사용합니다
**true**| 불리언 리터럴로 사용됩니다.
**try**| 예외를 생성할 수 있는 코드 블럭의 선언에 사용됩니다. `with` 나 `finally`와 함께 사용됩니다.
**type**| 클래스, 레코드, 구조체, 판별공용체(discriminated union), 열거체(enumeration type), 단위 유닛(unit of measure), 타입 약어(type abbreviation)에 사용됩니다.
**upcast**| 상속 체인에서 상위 타입으로 변환할 때에 사용합니다.
**use**| Dispose를 이용하여 자원을 해제할 수 있는 값들에 대해 let 대신 사용합니다.
**use**! | 비동기 작업에서 `let!` 대신 사용되며 Dispose를 이용하여 자원을 해제할 수 있는 값들에 대해 let 대신 사용합니다.
**val**| 제한적인 상황에서 타입에 멤버를 정의하거나 값을 지시하기 위한 서명에 사용됩니다.
**void**| .NET void 타입을 지시합니다. 다른 .NET 언어와 상호작용할 때에 사용합니다.
**when**| 패턴 매칭에서의 불리언 조건과 제너릭 타입 인자에 제약 절을 제시할 때에 사용됩니다.
**while**| 반복 구조를 제시합니다.
**with**| 패턴 매칭에서 `match` 키워드와 같이 사용됩니다. 또한 객체 표현에서 레코드 복사 표현이나 멤버 정의 제시나 예외 처리 제시를 위한 타입 확장에도 사용됩니다.
**yield**| 시퀀스의 값을 발생시키는 시퀀스 표현에 사용됩니다.
**yield**!| 계산 결과의 콜렉션에 주어진 계산 표현의 값을 덧붙일 때 사용됩니다.

OCaml에서 넘어온 키워드들은 다음과 같습니다.
 - asr
 - land
 - lor
 - lsl
 - lsr
 - lxor
 - mod
 - sig

F#의 추후 확장을 위해 예약된 키워드들은 다음과 같습니다.
 - atomic
 - break
 - checked
 - component
 - const 
 - constraint
 - constructor
 - continue
 - eager
 - event
 - external
 - fixed
 - functor
 - include
 - method
 - mixin
 - object
 - parallel
 - process
 - protected
 - pure
 - sealed
 - tailcall
 - trait
 - virtual
 - volatile

## F#에서의 주석
F#에서는 두 종류의 주석을 지원합니다
 - 한 줄의 주석은 `//` 기호로 시작합니다
 - 여러 줄의 주석은 `(*` 로 시작하며 `*)`로 끝납니다

## 간단한 프로그램과 F#에서의 프로그램 진입점
일반적으로 F# 프로그램을 위한 명시적인 진입점은 없습니다. F# 프로그램을 컴파일 할 때, 컴파일러에 마지막으로 주어진 파일이 진입점이 되고 그 파일의 최상위 수준으로 정의된 문들이 위에서부터 아래로 실행됩니다.

잘 작성된 프로그램은 프로그램의 메인 루프를 호출하는 하나의 최상위 문으로 구성되어야 한다.

화면에 'Hello World'를 출력하는 매우 간소화된 프로그램은 다음과 같다.
```fsharp
(* This is a comment *)
(* Sample Hello World program using F# *)
printfn "Hello World!"
```
프로그램을 컴파일하고 실행하면 다음과 같은 출력을 받을 수 있습니다.

```fsharp
Hello World!
```